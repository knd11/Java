- # Java
	- ## 1. Java 基础
	  collapsed:: true
		- ### ⽤户⾃⼰写⼀个String类，会发⽣什么？
	- ## 2. JVM
		- ### 简述 Java 垃圾回收机制
			- 在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。
		-
		- ### 如何判断一个对象是否存活？（GC 对象的判定方法）
		  collapsed:: true
			- 判断一个对象是否存活有两种方法：
			- >==**引用计数法**==：所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收。
			  引用计数法有一个缺陷就是无法解决==循环引用问题==，也就是说当对象 A 引用对象 B，对象 B 又引用者对象 A，那么此时 A、B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。
			-
			- >==**可达性算法**（引用链法）==：该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，
			  如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。
			  在 Java 中可以作为 GC Roots 的对象有以下几种：
			  • 虚拟机栈中引用的对象
			  • 方法区类静态属性引用的对象
			  • 方法区常量池引用的对象
			  • 本地方法栈 JNI 引用的对象
			  虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历==两次标记==。如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize() 方法 。当对象没有覆盖 finalize() 方法或者已被虚拟机调用过，那么就认为是没必要的。 如果该对象有必要执行finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除” 即将回收”集合，等待回收。
		-
		- ### 在 Java 中，对象什么时候可以被垃圾回收？
			- 当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。
		-
		- ### 深拷贝和浅拷贝。
			- >浅拷贝就是对对象中的数据成员进行简单赋值，如果存在动态成员或者指针就会报错。
			- >深拷贝就是对对象中存在的动态成员或指针重新开辟内存空间。
		-
		- ### 什么是类加载器，类加载器有哪些？
			- 实现通过类的权限定名获取该类的二进制字节流的代码块叫做==类加载器==。主要有一下四种类加载器：
			- >==启动类加载器==（Bootstrap Class Loader）：用来加载 Java 核心类库，无法被 Java 程序直接引用。
			- >==扩展类加载器== (Extensions Class Loader)：它用来加载 Java的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
			- >==系统类加载器==（System Class Loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。
			- >==用户自定义类加载器==，通过继承 java.lang.ClassLoader 类的方式实现。
		-
		-
		- ### 类加载器——双亲委派模型
			- 当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。
		-
	-
-
-